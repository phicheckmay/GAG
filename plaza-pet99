--// =============== ANTI-DUPLICATE =============== \\--
if getgenv().SimplePlazaSellerRunning then
    warn("[Simple Seller]: Script đã chạy rồi, không chạy lại trong cùng 1 game.")
    return
end
getgenv().SimplePlazaSellerRunning = true

--// ================== CONFIG ================== \\--

local CONFIG = {
    TARGET_NAME  = "Huge Blue Lucky Block", -- Tên pet đúng như trong túi
    TARGET_CLASS = "Pet",                   -- Class: "Pet"
    PRICE        = 15_000_000,              -- Giá bán: 15m diamonds
    PER_LIST     = 1,                       -- Mỗi listing bán 1 con
    MAX_SLOTS    = 25,                      -- Tối đa 25 slot
    LOOP_DELAY   = 3,                       -- Mỗi vòng cách nhau 3 giây
}

--// ============= KHÔNG SỬA DƯỚI NẾU KHÔNG RÕ ============= \\--

if not game:IsLoaded() then game.Loaded:Wait() end

local PS99 = {Pro = 15588442388, Normal = 15502339080}
if not table.find({PS99.Normal, PS99.Pro}, game.PlaceId) then
    warn("[Simple Seller]: Chỉ dùng trong Trading Plaza Pet Simulator 99.")
    return
end

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer       = Players.LocalPlayer

repeat task.wait() until LocalPlayer and LocalPlayer.GetAttribute and LocalPlayer:GetAttribute("__LOADED")
if not LocalPlayer.Character then LocalPlayer.CharacterAdded:Wait() end
local HumanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")

local TARGET_NAME  = CONFIG.TARGET_NAME
local TARGET_CLASS = CONFIG.TARGET_CLASS
local PRICE        = CONFIG.PRICE
local PER_LIST     = CONFIG.PER_LIST
local MAX_SLOTS    = CONFIG.MAX_SLOTS
local LOOP_DELAY   = CONFIG.LOOP_DELAY

-- Lấy Library gốc
local NLibrary = ReplicatedStorage:WaitForChild("Library")

-- Require module nhẹ
local okInv, InventoryCmds = pcall(require, NLibrary.Client.InventoryCmds)
if not okInv then
    warn("[Simple Seller]: Không require được InventoryCmds:", InventoryCmds)
    return
end

local okNet, Network = pcall(require, NLibrary.Client.Network)
if not okNet then
    warn("[Simple Seller]: Không require được Network:", Network)
    return
end

-- ================= LẤY BOOTHS STATE TỪ BoothCmds ================= --

local Booths, ClaimedBooths, BoothsInteractive

local function InitBooths()
    local boothScript = NLibrary.Client:FindFirstChild("BoothCmds")
        or LocalPlayer.PlayerScripts.Scripts.Game["Trading Plaza"]["Booths Frontend"]

    if not boothScript then
        warn("[Simple Seller]: Không tìm thấy BoothCmds / Booths Frontend.")
        return false
    end

    local env = getsenv(boothScript)
    local getState = env.getState
    local updateAllInteracts = env.updateAllInteracts

    if not getState or not updateAllInteracts then
        warn("[Simple Seller]: Không lấy được getState / updateAllInteracts.")
        return false
    end

    local boothsUp     = getupvalues(getState)
    local interactsUp  = getupvalues(updateAllInteracts)

    Booths            = boothsUp[1]         -- state booths
    ClaimedBooths     = interactsUp[1]      -- map player -> booth info
    BoothsInteractive = interactsUp[3]      -- BoothID -> model

    if not Booths or not ClaimedBooths or not BoothsInteractive then
        warn("[Simple Seller]: Upvalues Booths/ClaimedBooths/BoothsInteractive bị nil.")
        return false
    end

    return true
end

-- ================== BOOTH HELPERS ================== --

local function IsBoothAvailable(BoothID)
    for _, boothData in pairs(ClaimedBooths) do
        if boothData.BoothID == BoothID then
            return false
        end
    end
    return true
end

local function GetCenterX()
    local minX, maxX = math.huge, -math.huge
    for _, BoothModel in pairs(BoothsInteractive) do
        local x = BoothModel.Pets.Position.X
        if x < minX then minX = x end
        if x > maxX then maxX = x end
    end
    return (minX + maxX) / 2
end

local function GetBoothPriority(BoothModel, CenterX)
    local yPriority = BoothModel.Pets.Position.Y
    local xDistance = math.abs(BoothModel.Pets.Position.X - CenterX)
    return yPriority, xDistance
end

local function ClaimOptimalBooth()
    if ClaimedBooths[LocalPlayer] then
        return true
    end

    local BoothCandidates = {}
    local CenterX = GetCenterX()

    for BoothID, BoothModel in next, BoothsInteractive do
        if ClaimedBooths[LocalPlayer] then
            return true
        end
        if IsBoothAvailable(BoothID) then
            local yPriority, xDistance = GetBoothPriority(BoothModel, CenterX)
            table.insert(BoothCandidates, {
                BoothID   = BoothID,
                Model     = BoothModel,
                Y         = yPriority,
                xDistance = xDistance,
            })
        end
    end

    table.sort(BoothCandidates, function(a, b)
        if a.Y == b.Y then
            return a.xDistance < b.xDistance
        end
        return a.Y < b.Y
    end)

    for _, Booth in ipairs(BoothCandidates) do
        local ok, success = pcall(function()
            return Network.Invoke("Booths_ClaimBooth", Booth.BoothID)
        end)

        if ok and success then
            warn("[Simple Seller]: Claim booth thành công, ID:", Booth.BoothID)

            local Interact = Booth.Model:WaitForChild("Interact", 5)
            if Interact then
                pcall(function()
                    Network.Fire("Hoverboard_RequestUnequip")
                end)
                task.wait(0.5)
                HumanoidRootPart.CFrame =
                    Interact.CFrame * CFrame.new(0,-2,-6) * CFrame.Angles(0, math.rad(180), 0)
            end

            return true
        end
    end

    warn("[Simple Seller]: Không claim được booth nào.")
    return false
end

-- Lấy danh sách UID đang nằm trong booth của mình + số slot
local function GetMyBoothListings()
    local slotCount = 0
    local uidOnBooth = {}

    if not Booths or not ClaimedBooths[LocalPlayer] then
        return 0, uidOnBooth
    end

    for _, Users in next, Booths do
        for Username, Booth in next, Users do
            for BoothInfo, InfoValues in next, Booth do
                if BoothInfo == "Listings" and tostring(Username):find(LocalPlayer.Name) then
                    for uid, info in next, InfoValues do
                        slotCount += 1
                        uidOnBooth[uid] = true
                    end
                    return slotCount, uidOnBooth
                end
            end
        end
    end

    return slotCount, uidOnBooth
end

-- ================= TÌM PET KHÔNG NẰM TRÊN BOOTH ================= --

local function FindPetNotOnBooth(uidOnBooth)
    local ok, result = pcall(function()
        local state = InventoryCmds.State()
        if not state or not state.container or not state.container._store then
            return nil
        end

        local store  = state.container._store
        local byType = store._byType
        if not byType then return nil end

        local classTable = byType[TARGET_CLASS]
        if not classTable or not classTable._byUID then
            return nil
        end

        for uid, item in pairs(classTable._byUID) do
            if uidOnBooth[uid] then
                continue
            end

            local data   = item._data
            local id     = item.GetId and item:GetId() or data and data.id
            local locked = data and data._lk
            local amount = data and (data._am or 1) or 1

            if id == TARGET_NAME and not locked then
                return {uid = uid, amount = amount}
            end
        end

        return nil
    end)

    if not ok then
        warn("[Simple Seller]: Lỗi đọc inventory:", result)
        return nil
    end

    return result
end

-- ======================= MAIN LOOP ======================= --

task.spawn(function()
    warn("[Simple Seller]: BẮT ĐẦU. Script sẽ tự claim booth (nếu chưa) và auto list pet mỗi "
        .. tostring(LOOP_DELAY) .. " giây.")

    if not InitBooths() then
        warn("[Simple Seller]: InitBooths fail, dừng.")
        return
    end

    ClaimOptimalBooth()

    while true do
        -- Đảm bảo booth vẫn còn
        if not ClaimedBooths[LocalPlayer] then
            ClaimOptimalBooth()
        end

        local usedSlots, uidOnBooth = GetMyBoothListings()
        if usedSlots >= MAX_SLOTS then
            warn(string.format("[Simple Seller]: Booth full %d/%d slot, đợi bán bớt...", usedSlots, MAX_SLOTS))
        else
            local info = FindPetNotOnBooth(uidOnBooth)
            if info and info.uid then
                local toSell = math.min(PER_LIST, info.amount)

                warn(string.format(
                    "[Simple Seller]: Thử list '%s' x%d @ %d | Slot: %d/%d",
                    TARGET_NAME, toSell, PRICE, usedSlots, MAX_SLOTS
                ))

                local ok, res = pcall(function()
                    return Network.Invoke("Booths_CreateListing", info.uid, PRICE, toSell)
                end)

                if not ok then
                    warn("[Simple Seller]: Lỗi Booths_CreateListing:", res)
                elseif not res then
                    warn("[Simple Seller]: Booths_CreateListing trả về FALSE (limit / lỗi server).")
                else
                    warn("[Simple Seller]: List thành công 1 listing.")
                end
            else
                warn("[Simple Seller]: Không còn pet '"..TARGET_NAME.."' chưa treo trên booth.")
            end
        end

        task.wait(LOOP_DELAY)
    end
end)
