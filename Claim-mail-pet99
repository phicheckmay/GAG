-- Ngăn chạy trùng nhiều lần
getgenv().SimplePlazaSellerRunning = getgenv().SimplePlazaSellerRunning or false
if getgenv().SimplePlazaSellerRunning then
    warn("[Simple Seller]: Script đã chạy rồi, không tạo thêm.")
    return
end
getgenv().SimplePlazaSellerRunning = true

--// ================== CONFIG ================== \\--

local CONFIG = {
    LOOP_DELAY       = 3,        -- Delay giữa mỗi vòng list (giây)

    AUTO_CLAIM_BOOTH = true,     -- true = auto claim booth; false = bạn tự claim/mở booth
    MAX_BOOTH_ID     = 50,       -- brute force Booths_ClaimBooth(id) từ 1..MAX_BOOTH_ID nếu cần

    -- Danh sách các pet cần treo:
    PETS = {
        {
            Name    = "Huge Blue Lucky Block",
            Class   = "Pet",
            Price   = 15_000_000,  -- 15m
            PerList = 1,           -- mỗi listing bán 1 con
        },
        {
            Name    = "Golden Mossy Lamb",
            Class   = "Pet",
            Price   = 10_000_000,  -- 10m
            PerList = 1,
        },
        -- thêm pet khác ở đây:
        -- {
        --     Name    = "Tên Pet 3",
        --     Class   = "Pet",
        --     Price   = 123_456_789,
        --     PerList = 1,
        -- },
    }
}

--// ============= KHÔNG SỬA DƯỚI NẾU KHÔNG RÕ ============= \\--

if not game:IsLoaded() then game.Loaded:Wait() end

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService   = game:GetService("TeleportService")

local LocalPlayer       = Players.LocalPlayer
if not LocalPlayer then
    repeat task.wait() until Players.LocalPlayer
    LocalPlayer = Players.LocalPlayer
end

-- ================== PLACE CHECK + TELEPORT ================== --

local PS99 = {Pro = 15588442388, Normal = 15502339080}

local function IsInPlaza()
    return game.PlaceId == PS99.Normal or game.PlaceId == PS99.Pro
end

if not IsInPlaza() then
    warn("[Simple Seller]: Không ở Trading Plaza -> Teleport vào Plaza Normal...")
    TeleportService:Teleport(PS99.Normal, LocalPlayer)
    -- Khi sang Plaza Normal, autoexec sẽ chạy lại script này.
    return
end

-- Đảm bảo client đã load xong mấy thứ của game
repeat task.wait() until LocalPlayer and LocalPlayer.GetAttribute and LocalPlayer:GetAttribute("__LOADED")
if not LocalPlayer.Character then LocalPlayer.CharacterAdded:Wait() end

local LOOP_DELAY   = CONFIG.LOOP_DELAY
local AUTO_CLAIM   = CONFIG.AUTO_CLAIM_BOOTH
local MAX_BOOTH_ID = CONFIG.MAX_BOOTH_ID
local PETS_CONFIG  = CONFIG.PETS

-- Lấy Library gốc
local NLibrary = ReplicatedStorage:WaitForChild("Library")

-- Require module cần thiết (rất nhẹ)
local okInv, InventoryCmds = pcall(require, NLibrary.Client.InventoryCmds)
if not okInv then
    warn("[Simple Seller]: Không require được InventoryCmds:", InventoryCmds)
    return
end

local okNet, Network = pcall(require, NLibrary.Client.Network)
if not okNet then
    warn("[Simple Seller]: Không require được Network:", Network)
    return
end

-- ================== WAIT CHARACTER / HRP ================== --

local HumanoidRootPart

local function WaitForCharacter()
    local char = LocalPlayer.Character
    if not char then
        char = LocalPlayer.CharacterAdded:Wait()
    end
    while not char:FindFirstChild("HumanoidRootPart") do
        char.ChildAdded:Wait()
    end
    HumanoidRootPart = char.HumanoidRootPart
    return char
end

WaitForCharacter()

-- ================== AUTO CLAIM BOOTH (KIỂU CŨ, AN TOÀN) ================== --

local function AutoClaimBoothSimple()
    if not AUTO_CLAIM then
        warn("[Simple Seller]: AUTO_CLAIM_BOOTH = false -> không tự claim booth.")
        return
    end

    if getgenv().SimplePlazaSellerBoothTried then
        return
    end
    getgenv().SimplePlazaSellerBoothTried = true

    warn("[Simple Seller]: (Fallback) Thử auto claim booth kiểu đơn giản...")

    -- Cách 1: không truyền ID
    local ok1, res1 = pcall(function()
        return Network.Invoke("Booths_ClaimBooth")
    end)

    if ok1 and res1 then
        warn("[Simple Seller]: Auto claim booth (simple) thành công (không cần ID).")
        return
    end

    -- Cách 2: brute-force ID 1..MAX_BOOTH_ID
    for id = 1, MAX_BOOTH_ID do
        local ok2, res2 = pcall(function()
            return Network.Invoke("Booths_ClaimBooth", id)
        end)

        if ok2 and res2 then
            warn(string.format("[Simple Seller]: Auto claim booth (simple) thành công với ID %d.", id))
            return
        end

        task.wait(0.05)
    end

    warn("[Simple Seller]: Auto claim booth (simple) thất bại (có thể đã có booth sẵn / game đổi logic).")
end

-- ================== BIẾN DÙNG CHO BOOTH (ADVANCED) ================== --

local Booths, ClaimedBooths, BoothsInteractive

local function FindBoothScriptInPlayerScripts()
    local ps = LocalPlayer:FindFirstChild("PlayerScripts")
    if not ps then return nil end

    local scriptsFolder = ps:FindFirstChild("Scripts")
    if not scriptsFolder then return nil end

    local gameFolder = scriptsFolder:FindFirstChild("Game")
    if not gameFolder then return nil end

    local plazaFolder = gameFolder:FindFirstChild("Trading Plaza")
    if not plazaFolder then return nil end

    return plazaFolder:FindFirstChild("Booths Frontend")
        or plazaFolder:FindFirstChild("Booths")
        or plazaFolder:FindFirstChild("BoothsFrontend")
end

-- ================== INIT BOOTHS (ADVANCED, CÓ PCALL) ================== --

local function InitBooths()
    local boothScript = NLibrary.Client:FindFirstChild("BoothCmds")
                     or FindBoothScriptInPlayerScripts()

    if not boothScript then
        warn("[Simple Seller]: Không tìm thấy BoothCmds / Booths Frontend (InitBooths fail).")
        return false
    end

    local okEnv, env = pcall(getsenv, boothScript)
    if not okEnv or type(env) ~= "table" then
        warn("[Simple Seller]: getsenv(boothScript) fail, dùng fallback simple claim.")
        return false
    end

    local getState           = env.getState
    local updateAllInteracts = env.updateAllInteracts

    if not getState or not updateAllInteracts then
        warn("[Simple Seller]: Không lấy được getState / updateAllInteracts trong env.")
        return false
    end

    local okUp1, boothsUp    = pcall(getupvalues, getState)
    local okUp2, interactsUp = pcall(getupvalues, updateAllInteracts)

    if not okUp1 or not okUp2 or type(boothsUp) ~= "table" or type(interactsUp) ~= "table" then
        warn("[Simple Seller]: getupvalues(getState/updateAllInteracts) fail.")
        return false
    end

    Booths            = boothsUp[1]         -- state booths
    ClaimedBooths     = interactsUp[1]      -- map player -> booth info
    BoothsInteractive = interactsUp[3]      -- BoothID -> model

    if not Booths or not ClaimedBooths or not BoothsInteractive then
        warn("[Simple Seller]: Upvalues Booths/ClaimedBooths/BoothsInteractive bị nil.")
        return false
    end

    warn("[Simple Seller]: InitBooths OK (advanced).")
    return true
end

-- ================== BOOTH HELPERS (ADVANCED) ================== --

local function IsBoothAvailable(BoothID)
    if not ClaimedBooths then return false end
    for _, boothData in pairs(ClaimedBooths) do
        if boothData.BoothID == BoothID then
            return false
        end
    end
    return true
end

local function GetCenterX()
    local minX, maxX = math.huge, -math.huge
    for _, BoothModel in pairs(BoothsInteractive or {}) do
        local x = BoothModel.Pets.Position.X
        if x < minX then minX = x end
        if x > maxX then maxX = x end
    end
    return (minX + maxX) / 2
end

local function GetBoothPriority(BoothModel, CenterX)
    local yPriority = BoothModel.Pets.Position.Y
    local xDistance = math.abs(BoothModel.Pets.Position.X - CenterX)
    return yPriority, xDistance
end

local function ClaimOptimalBooth()
    if not Booths or not ClaimedBooths or not BoothsInteractive then
        return false
    end

    if ClaimedBooths[LocalPlayer] then
        warn("[Simple Seller]: Đã có booth sẵn rồi (advanced).")
        return true
    end

    local BoothCandidates = {}
    local CenterX = GetCenterX()

    for BoothID, BoothModel in next, BoothsInteractive do
        if ClaimedBooths[LocalPlayer] then
            return true
        end
        if IsBoothAvailable(BoothID) then
            local yPriority, xDistance = GetBoothPriority(BoothModel, CenterX)
            table.insert(BoothCandidates, {
                BoothID   = BoothID,
                Model     = BoothModel,
                Y         = yPriority,
                xDistance = xDistance,
            })
        end
    end

    table.sort(BoothCandidates, function(a, b)
        if a.Y == b.Y then
            return a.xDistance < b.xDistance
        end
        return a.Y < b.Y
    end)

    for _, Booth in ipairs(BoothCandidates) do
        local ok, success = pcall(function()
            return Network.Invoke("Booths_ClaimBooth", Booth.BoothID)
        end)

        if ok and success then
            warn("[Simple Seller]: Claim booth (advanced) thành công, ID:", Booth.BoothID)

            local Interact = Booth.Model:WaitForChild("Interact", 5)
            if Interact and HumanoidRootPart then
                pcall(function()
                    Network.Fire("Hoverboard_RequestUnequip")
                end)
                task.wait(0.5)
                HumanoidRootPart.CFrame =
                    Interact.CFrame * CFrame.new(0,-2,-6) * CFrame.Angles(0, math.rad(180), 0)
            end

            return true
        end
    end

    warn("[Simple Seller]: ClaimOptimalBooth không claim được booth nào.")
    return false
end

-- ================== TRACK UID ĐÃ LIST ================== --
-- 1 UID list được 1 lần; nếu muốn list tiếp phải là UID khác (bản khác của pet)

local ListedUIDs = {}   -- uid -> true

-- Tìm pet phù hợp cho 1 cấu hình petCfg, bỏ qua UID đã list
local function FindNextPet(petCfg)
    local targetName  = petCfg.Name
    local targetClass = petCfg.Class or "Pet"

    local ok, result = pcall(function()
        local state = InventoryCmds.State()
        if not state or not state.container or not state.container._store then
            return nil
        end

        local store  = state.container._store
        local byType = store._byType
        if not byType then return nil end

        local classTable = byType[targetClass]
        if not classTable or not classTable._byUID then
            return nil
        end

        for uid, item in pairs(classTable._byUID) do
            if ListedUIDs[uid] then
                continue
            end

            local data   = item._data
            local id     = item.GetId and item:GetId() or data and data.id
            local locked = data and data._lk
            local amount = data and (data._am or 1) or 1

            if id == targetName and not locked and amount > 0 then
                return {uid = uid, amount = amount}
            end
        end

        return nil
    end)

    if not ok then
        warn("[Simple Seller]: Lỗi đọc inventory:", result)
        return nil
    end

    return result
end

-- ======================= MAIN LOOP ======================= --

task.spawn(function()
    warn("[Simple Seller]: BẮT ĐẦU.")

    local boothInitOk = false
    if AUTO_CLAIM then
        boothInitOk = InitBooths()
        if boothInitOk then
            local ok = ClaimOptimalBooth()
            if not ok then
                -- nếu claim optimal fail thì fallback simple
                AutoClaimBoothSimple()
            end
        else
            -- nếu init booths fail (PC, executor chặn getsenv / getupvalues), dùng simple
            AutoClaimBoothSimple()
        end
    else
        warn("[Simple Seller]: AUTO_CLAIM_BOOTH = false -> bạn tự claim/mở booth, script chỉ list pet.")
    end

    -- (QUAN TRỌNG) KHÔNG lấy UID sẵn trên booth nữa để tránh bug không list trên LD
    -- trước đây GetMyBoothListings có thể mark nhầm UID => script nghĩ pet đã list hết

    local firstLoop = true

    while true do
        local anyListedThisLoop = false

        -- Mỗi vòng: thử list từng pet trong danh sách
        for _, petCfg in ipairs(PETS_CONFIG) do
            local info = FindNextPet(petCfg)

            if info and info.uid then
                local toSell = math.min(petCfg.PerList or 1, info.amount)
                local price  = petCfg.Price

                warn(string.format(
                    "[Simple Seller]: Thử list '%s' x%d @ %d",
                    petCfg.Name, toSell, price
                ))

                local ok, res = pcall(function()
                    return Network.Invoke("Booths_CreateListing", info.uid, price, toSell)
                end)

                if not ok then
                    warn("[Simple Seller]: Lỗi Booths_CreateListing:", res)
                elseif not res then
                    -- thường là full slot / chưa mở booth / limit
                    warn("[Simple Seller]: Booths_CreateListing trả về FALSE (có thể full slot / chưa mở booth / limit).")
                else
                    ListedUIDs[info.uid] = true
                    anyListedThisLoop    = true
                    warn(string.format(
                        "[Simple Seller]: List thành công UID %s (%s).",
                        tostring(info.uid), petCfg.Name
                    ))
                end
            else
                if firstLoop then
                    warn("[Simple Seller]: Không tìm thấy pet '"..petCfg.Name.."' (có thể hết hoặc đang bị lock).")
                end
            end

            -- nghỉ tí giữa các pet cho đỡ spam
            task.wait(0.1)
        end

        firstLoop = false

        if not anyListedThisLoop then
            warn("[Simple Seller]: Không còn pet nào phù hợp để list trong vòng này, chờ "..tostring(LOOP_DELAY).."s rồi thử lại.")
        end

        task.wait(LOOP_DELAY)
    end
end)
